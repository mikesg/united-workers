#encoding: utf-8

require 'spec_helper'

describe UnitedWorkers::Interceptor do
  def synchronous_queue
    queue = double
    def queue.subscribe(*args, &block)
      @block = block
    end
    def queue.publish(message, params = {})
      @block.call(delivery_info, nil, message)
    end
    allow(queue).to receive(:delivery_info).and_return(double.as_null_object)
    allow(queue).to receive(:channel).and_return(double.as_null_object)
    queue
  end

  it 'subscribes to external queue' do
    queue = double
    expect(UnitedWorkers::Queue).to receive(:get).with(:external).and_return(queue)
    expect(queue).to receive(:subscribe)

    UnitedWorkers::Interceptor.start(:external, :internal){}
  end

  it 'gives the message params to the coroutine specified' do
    queue = synchronous_queue
    target = double
    allow(UnitedWorkers::Queue).to receive(:get).with(:external).and_return queue
    allow(UnitedWorkers::Queue).to receive(:get).with(:internal)

    expect(target).to receive(:received).with("Start!")
    interceptor = UnitedWorkers::Interceptor.start(:external, :internal){ |message|
      target.received message
      []
    }

    queue.publish("Start!")
  end

  it 'publishes in the internal queue the tasks generated by the coroutine' do
    external_queue = synchronous_queue
    internal_queue = synchronous_queue
    allow(UnitedWorkers::Queue).to receive(:get).with(:external).and_return external_queue
    allow(UnitedWorkers::Queue).to receive(:get).with(:internal).and_return internal_queue

    interceptor = UnitedWorkers::Interceptor.start(:external, :internal){ |message|
      [["task1", "Message1"], ["task2", "Message2"]]
    }
    calls = []
    internal_queue.subscribe { |_,__,msg| calls << msg }

    external_queue.publish("Start!")
    expect(calls.count).to eq 2
  end
end
